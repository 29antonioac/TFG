\chapter{Desarrollo}

<<setup05, cache = FALSE, include = FALSE>>=
read_chunk("../scripts/05_Desarrollo.R")
@

Este trabajo ha sido desarrollando utilizando las siguientes herramientas:

\begin{itemize}
  \item \LaTeX \, como procesador de textos científico.
  \item \emph{R} como lenguaje de tratamiento de datos. Junto a \emph{knitr},
  se ha escrito este documento con el paradigma de \emph{programación literaria},
  donde el documento y los programas están en simbiosis, ofreciendo comodidad
  tanto para escribir como para leer.
  \item MariaDB como sistema gestor de bases de datos relacionales (SQL).
\end{itemize}

Estas decisiones se han tomado, principalmente, por ser las mejores herramientas
en cada uno de sus ámbitos, con la grandísima ventaja de ser software libre.

\improvement{¿Por qué son las mejores?}

Además, la plataforma donde se ha realizado la computación, es la siguiente:
\begin{itemize}
  \item Sistema operativo GNU/Linux - Archlinux x86\_64
  \item Intel i7 6700K @ 4.2Ghz
  \item G.Skill Ripjaws V DDR4 2400Mhz 4x8GB
  \item eVGA GTX 960 4GB ACX2.0+
  \item 2x128GB SSD + 2x750GB HDD en RAID0 vía hardware
\end{itemize}

La decisión de usar un RAID0 es por la falta de discos para formar un sistema
con redundancia. Con este sistema tenemos un sistema rápido y de gran capacidad,
para albergar las grandes bases de datos que se precisan, aunque sin tolerancia
a fallos. Al ser vía hardware, la tasa de fallo es mucho menor que uno vía
software, por lo que en un entorno doméstico es suficiente.


\section{Matemáticas}
<<mates, child='05_Desarrollo_Matematicas.Rnw'>>=
@


\newpage
\section{Ingeniería Informática}
\label{sec:informatica}
Una vez se dispone de todas las herramientas matemáticas necesarias,
se puede comenzar con el desarrollo de la parte de Ingeniería Informática que
se aborda en el trabajo.

\subsection{Comprensión del problema y de los datos}
\label{subsec:comprension}

En primer lugar en cualquier problema de Ciencia de Datos, el primer
paso es \emph{comprender el problema y los datos que se disponen}.

\change{Meter cita!}
El problema a abordar es el siguiente: a partir de un conjunto de
partidas antiguas de StarCraft, se busca predecir
el momento en el que la partida está decidida con una confianza
determinada. Para ello, partimos de 6 bases de datos relacionales
(SQL) con gran cantidad de partidas almacenadas, cada una con muchas
características a observar. Cada una de ellas posee las
características presentes en la figura~\ref{dataset}.


\begin{figure}
    \centering
    \includegraphics[width=\maxwidth]{figure/Robertson14DatabaseDiagram}
    \caption{Base de datos de partidas de StarCraft}
    \label{dataset}
\end{figure}



Una vez se tiene conocimiento del problema y un conjunto de datos, se
debe decidir qué datos y características van a ser usados y de qué
forma. El principal problema de este paso es conocer el conjunto de
datos del que se dispone, ya que usualmente no es extraído por los
investigadores.

Las características están sacadas casi en su totalidad directamente de
valores que proporciona la API que permite interactuar con StarCraft,
\emph{BWAPI}. Otros son datos derivados, como la distancia de un
jugador a la base más cercana, por ejemplo.

Las características que van a ser usados en este trabajo son,
principalmente, los recursos de cada jugador, sus batallones (que son
medidos de una manera determinada que se explican con más detalle más
adelante), sus construcciones, y los valores estimados de batallones y
construcciones que tienen un jugador del otro. Además, también se tiene
en cuenta los recursos restantes del mapa que cada jugador estima que
quedan. Estas características quedan reflejadas en la figura
~\ref{datasetSeleccionado}. Estas características han sido escogidas ya que se
pretende realizar un análisis utilizando el estado actual del entorno, no
una cola de eventos producidos por los jugadores. Este enfoque se ha realizado
en otros trabajos.

\change{Meter cita aquí}

\begin{figure}
    \centering
    \includegraphics[width=\maxwidth]{figure/Robertson14DatabaseDiagramSeleccion}
    \caption{Características seleccionadas de las bases de datos}
    \label{datasetSeleccionado}
\end{figure}


Estas características son, según cada tabla:

\begin{itemize}
  \item replay: Esta tabla contiene datos asociados a cada partida.
  \begin{itemize}
    \item ReplayID: Identificador de cada partida.
    \item Duration: Duración (en frames) de cada partida. 15 frames equivalen a 1 segundo.
  \end{itemize}
  \item playerreplay: Esta tabla contiene datos asociados a un jugador en una partida.
  \begin{itemize}
    \item PlayerReplayID: Identificador de un jugador en una partida.
    \item ReplayID: Identificador de partida asociado.
    \item Winner: Ganador de cada partida.
  \end{itemize}
  \item resourcechange: Esta tabla contiene datos asociados a cambios en los recursos de un jugador.
  \begin{itemize}
    \item PlayerReplayID: Identificador del jugador que produce un cambio.
    \item Frame: Frame en el que se produce un cambio.
    \item Minerals: Cantidad de minerales que tiene un jugador en ese momento.
    \item Gas: Cantidad de gas que tiene un jugador en ese momento.
    \item Supply: Capacidad de carga del jugador.
    \item TotalMinerals: Cantidad total de minerales que ha obtenido un jugador, sin contar gastos.
    \item TotalGas: Cantidad total de gas que ha obtenido un jugador, sin contar gastos.
    \item TotalSupply: Capacidad que ha obtenido un jugador, sin contar gastos.
  \end{itemize}
  \item regionvaluechange: Esta tabla contiene datos asociados a cambios de un jugador
  en una región del mapa determinada. Cada \emph{value}, que llamaremos de aquí en adelante
  \emph{valor}, es la suma del precio de una unidad en Minerales y Gas.
  \begin{itemize}
    \item PlayerReplayID: Identificador del jugador que produce un cambio.
    \item RegionID: Identificador de la región del mapa donde se produce un cambio.
    \item Frame: Frame en el que se produce el cambio.
    \item GroundUnitValue: Valor de las unidades terrestres en esta región.
    \item BuildingValue: Valor de las construcciones en esta región.
    \item AirUnitValue: Valor de las unidades aéreas en esta región.
    \item EnemyGroundUnitValue: Valor de las unidades terrestres del enemigo en esta región.
    Este valor es estimado, sólo se conoce lo que el jugador puede ver del enemigo.
    \item EnemyBuildingValue: Valor de las construcciones del enemigo en esta región.
    Este valor es estimado, sólo se conoce lo que el jugador puede ver del enemigo.
    \item EnemyAirUnitValue: Valor de las unidades aéreas del enemigo en esta región.
    Este valor es estimado, sólo se conoce lo que el jugador puede ver del enemigo.
    \item ResourceValue: Valor de los recursos en esta región. Este valor es estimado,
    sólo se conoce lo que el jugador puede ver del mapa. Si el jugador no conoce una zona, estima que los recursos restantes es la totalidad de lo disponible en la región.
  \end{itemize}
\end{itemize}

Una vez se ha decidido qué vamos a usar, hay que pasar al cómo.
Esta fase es el \emph{preprocesamiento de los datos}, que es la fase donde se
organizan los datos, se corrigen si hubiera datos perdidos o ruido...
para poder abordar el problema a resolver.

\subsection{Preprocesamiento de datos}
\label{subsec:preprocesamiento}

En esta sección se expone el trabajo de preprocesado que se ha tenido que aplicar
a los datos para poder obtener información.
\todo[inline]{Aquí meter toda la lógica que se ha usado para extraer los datos. Qué y cómo se ha hecho.}

\subsubsection{Preparación del sistema para almacenar los datos}
\label{subsubsec:preparacion}

En primer lugar, se tiene que ver qué formato tienen los datos para saber cómo
manejarse con ellos. Los datos vienen estructurados en sendos scripts de bases
de datos estructurales \emph{SQL}, por lo que el primer paso es montar un
\emph{Sistema Gestor de Bases de Datos}. Como se ha expuesto al comienzo del
capítulo, el elegido ha sido \emph{MariaDB}, que es la implementación totalmente
libre del archiconocido \emph{MySQL}.

Esto se ha realizado en el desarrollo del Grado, por lo que no se detallará.
Lo único que se ha ampliado con respecto a los conocimientos adquiridos es el
montaje del espacio reservado para las bases de datos en un lugar distinto
al que viene por defecto. En este caso, se ha montado sobre una partición de
300GiB en un RAID0 de HDD's que previamente se ha montado en el sistema,
utilizando conocimientos adquiridos también en el Grado. Además, se ha
redireccionado la ruta temporal de \emph{MariaDB} a RAM para que el
procesamiento de las tablas esté íntegro en memoria y sea más rápido.

La configuración extra se aplica al archivo \texttt{/etc/mysql/my.cnf},
cambiando esta línea introduciendo la ruta donde se desea montar los archivos
temporales.

\begin{lstlisting}
  tmpdir          = /var/lib/mysqltmp
\end{lstlisting}

Además, se debe montar en memoria utilizando el archivo \texttt{/etc/fstab},
donde también se montará el directorio por defecto de \emph{MariaDB} en una
partición alojada en el RAID0.

\begin{lstlisting}

  # MySQL
  tmpfs   /var/lib/mysqltmp   tmpfs   rw,gid=89,uid=89,size=1G,mode=0750,noatime   0 0
  UUID=0e20a9fc-69df-4196-9545-6ce884491219       /var/lib/mysql  ext4           rw,noatime       0 3
\end{lstlisting}

Donde \emph{UUID} es el \emph{universally unique identifier} de la partición
donde se alojarán las bases de datos, y
\emph{gid} y \emph{uid} los identificadores del usuario y grupo \emph{mysql}.

Una vez se tiene funcionando un \emph{Sistema Gestor de Bases de Datos},
se procede a introducir las bases de datos proporcionadas. Al estar en formato
script \texttt{.sql} sólo hay que ejecutarlos con el intérprete.

Las bases de datos constan de seis scripts, de los cuales tres están ejecutados
con una versión antigua del extractor de datos, luego les falta una línea al
principio del script para situar al \emph{Sistema Gestor de Bases de Datos} en
la base de datos donde se introducen datos. Por ello, se ha utilizado el editor
de text \texttt{joe} para introducir dicha línea. Este editor se ha comportado
bien con archivos de gran tamaño (incluso de varios GiB), cosa que no se ha
conseguido con ningún otro editor.

\subsubsection{Preparación de un dataset limpio utilizando SQL}
\label{subsubsec:SQL}

Una vez se tienen las bases de datos importadas en el sistema, hay que fijarse
bien cómo están estructurados los datos que se quieren extraer para atacar la
base de datos de manera correcta. Para ello hay que estudiar bien el diagrama
mostrado antes, presente en la figura~\ref{datasetSeleccionado}, además de
examinar la base de datos de manera interactiva.




\subsubsection{Análisis exploratorio de datos}
\label{subsubsec:exploratorio}

\todo[inline]{Aquí todo lo referente al análisis exploratorio de datos. \newline
              Meter gráficas chulas.}


Histograma

<<replaysHistogram, echo = FALSE, fig.cap = "Duración de las partidas de la base de datos">>=
@

Histograma por razas

<<replaysRacesHistogram, echo = FALSE, fig.cap = "Duración de las partidas según la raza">>=
@

Histograma con partidas más cortas

<<replaysBoundHistogram, echo = FALSE, fig.cap = "Duración de las partidas menores a 75000 frames">>=
@

Cargar facets
<<loadReplayMelt, include = FALSE>>=
replays.melt.plots <- readRDS("../datos/replays.melt.plots.rds")
@

Recursos básicos

<<replaysMelt1, echo = FALSE, fig.cap = "1">>=
replays.melt.plots[[1]]
@

Total de recursos

<<replaysMelt2, echo = FALSE, fig.cap = "2">>=
replays.melt.plots[[2]]
@

Unidades

<<replaysMelt3, echo = FALSE, fig.cap = "3">>=
replays.melt.plots[[3]]
@

Unidades observadas

<<replaysMelt4, echo = FALSE, fig.cap = "4">>=
replays.melt.plots[[4]]
@

Recursos observados

<<replaysMelt5, echo = FALSE, fig.cap = "5">>=
replays.melt.plots[[5]]
@




\subsection{Extracción de información}
\label{subsec:extraccion}

\subsection{Interpretación y Evaluación}
\label{subsec:evaluacion}

<<loadPlots, include = FALSE>>=
plots <- readRDS("../resultados/errorplots.rds")
@

<<plot100, echo = FALSE, fig.width = 7, fig.height = 7, fig.cap = "Error e importancia del clasificador con límite la media">>=
multiplot(plotlist = plots[1,])
@

<<plot75, echo = FALSE, fig.width = 7, fig.height = 7, fig.cap = "Error e importancia del clasificador con límite el 75 de la media">>=
multiplot(plotlist = plots[6,])
@

<<plot50, echo = FALSE, fig.width = 7, fig.height = 7, fig.cap = "Error e importancia del clasificador con límite el 50 de la media">>=
multiplot(plotlist = plots[5,])
@

<<plot25, echo = FALSE, fig.width = 7, fig.height = 7, fig.cap = "Error e importancia del clasificador con límite el 25 de la media">>=
multiplot(plotlist = plots[4,])
@

<<plot20, echo = FALSE, fig.width = 7, fig.height = 7, fig.cap = "Error e importancia del clasificador con límite el 20 de la media">>=
multiplot(plotlist = plots[3,])
@

<<plot10, echo = FALSE, fig.width = 7, fig.height = 7, fig.cap = "Error e importancia del clasificador con límite el 10 de la media">>=
multiplot(plotlist = plots[2,])
@
